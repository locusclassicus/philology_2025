# Нормализация. Регулярные выражения 

Есть старая шутка, ее приписывают программисту Джейми Завински: если у вас есть проблема, и вы собираетесь ее решать при помощи регулярных выражений, то у вас две проблемы. Регулярные выражения -- это формальный язык, который используется для того, чтобы находить, извлекать и заменять части текста. 

Регулярные выражения (regex, regexp) объединяют _буквальные символы_ (литералы) и _метасимволы_ (символы-джокеры, англ. wildcard characters). 

Для поиска используется строка-образец (англ. pattern, по-русски её часто называют "шаблоном", "маской"), которая задает правило поиска. Строка замены также может содержать в себе специальные символы. 

Отличный путеводитель по миру регулярных выражений можно найти [здесь](https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html).

```{r}
library(tidyverse)
```

## Литералы и классы

Буквальные символы -- это то, что вы ожидаете увидеть (или не увидеть -- для управляющих и пробельных символов); можно сказать, что это символы, которые ничего не "имеют в виду". Их можно объединять в классы при помощи квадратных скобок, например, так: `[abc]`.

```{r}
library(stringr)

vec <- c("a", "d", "c")

# возвращает TRUE/FALSE
str_detect(vec, "[abc]")

# возвращает индексы совпадений  
str_which(vec, "[abc]")

# возвращает сами совпадающие элементы
str_subset(vec, "[abc]")
```

Для некоторых классов есть специальные обозначения.

|Класс | Эквивалент | Значение|
|----- | ------- | -----|
| [:upper:] |	[A-Z] |	Символы верхнего регистра |
| [:lower:] |	[a-z] |	Символы нижнего регистра |
| [:alpha:] |	[[:upper:][:lower:]] |	Буквы |
| [:digit:] |	[0-9], т. е. \\d  |	Цифры |
| [:alnum:] |	[[:alpha:][:digit:]] |	Буквы и цифры |
| [:word:] 	| [[:alnum:]_], т. е. \\w |	Символы, образующие «слово» |
| [:punct:] |	[-!"#$%&'()*+,./:;<=>?@[\\\]_`{\|}~] |	Знаки пунктуации |
| [:blank:] |	[\\s\\t] |	Пробел и табуляция |
| [:space:] |	[[:blank:]\\v\\r\\n\\f], т. е. \\s |	Пробельные символы |
|[:cntrl:] |	 |	Управляющие символы (перевод строки, табуляция и т.п.) |
| [:graph:] |	 |	Печатные символы |
| [:print:] |	 |	Печатные символы с пробелом |

Эти классы тоже можно задавать в качестве паттерна.

```{r}
vec <- c("жираф", "верблюд1", "99зeбра")

# заменяет все вхождения
str_replace_all(vec, "[[:digit:]]", "")

# заменяет только первое вхождение
str_replace(vec, "[[:digit:]]", "")
```

</br>

:::{.callout-warning icon=false}
В пакете `stringr` есть небольшой датасет `words`. Найдите все слова с последовательностью символов wh.  Сколько слов содержат два гласных после w?
:::

</br>


В качестве классов можно рассматривать и следующие обозначения:

| Представление |	Эквивалент | 	Значение |
|-------------- | ---------- | ----------|
| \\d |	[0-9] |	Цифра |
| \\D |	[^\\d] |	Любой символ, кроме цифры |
| \\w |	[A-Za-zА-Яа-я0-9_] |	Символы, образующие «слово» (буквы, цифры и символ подчёркивания) |
| \\W |	[^\\w] |	Символы, не образующие «слово» |
| \\s |	[ \\t\\v\\r\\n\\f] |	Пробельный символ |
| \\S |	[^\\s] |	Непробельный символ |

```{r}
str_replace_all(vec, "\\d",  "") # вторая косая черта "экранирует" первую
```

Внутри квадратных скобор знак `^` означает отрицание:

```{r}
str_remove_all(vec, "[^[:digit:]]") 
```

</br>

:::{.callout-warning icon=false}
Найдите все слова в `words`, в которых за w следует согласный. Замените всю пунктуацию в строке "tomorrow?and-tomorrow_and!tomorrow" на пробелы.
:::

</br>



## Якоря

Якоря позволяют искать последовательности символов в начале или в конце строки. Знак `^` (вне квадратных скобок!) означает начало строки, а знак `$` -- конец. Мнемоническое правило: First you get the power (^) and then you get the money ($).

```{r}
vec <- c("The spring is a lovely time", 
         "Fall is a time of peace")
str_which(vec, "time$")
```

</br>

:::{.callout-warning icon=false}
Найдите все слова в `words`, которые заканчиваются на x. Найдите все слова, которые начинаются на b или на g.
:::

</br>


## Метасимволы

Все метасимволы представлены в таблице ниже.

| Описание |	Символ |
| ---------| --------| 
|открывающая квадратная скобка |	[ |
|закрывающая квадратная скобка |	] |
|обратная косая черта |	\\ |
|карет |	^ |
|знак доллара |	$ |
|точка |	. |
|вертикальная черта |	\| |
|знак вопроса |	? |
|астериск |	* |
|плюс |	+ |
|открывающая фигурная скобка |	\{ |
|закрывающая фигурная скобка |	\} |
|открывающая круглая скобка |	( |
|закрывающая круглая скобка	| ) |

Квадратные скобки используются для создания классов, карет и знак доллара -- это якоря, но карет внутри квадратных скобок может также быть отрицанием. Точка -- это любой знак. 

```{r}
vec <- c("бегемот", "верблюд1", "0зебра")
str_subset(vec, ".б") 
```


</br>

:::{.callout-warning icon=false}
Найдите все слова в `words`, в которых есть любые два символа между b и k.
:::

</br>


## Экранирование

Если необходимо найти буквальную точку, буквальный знак вопроса и т.п., то используется экранирование: перед знаком ставится косая черта. Но так как сама косая черта -- это метасимвол, но нужно две косые черты, первая из которых экранирует вторую.

```{r}
vec <- c("жираф?", "верблюд.", "зебра")
str_subset(vec, "\\?") 
str_subset(vec, "\\.")
```

</br>

:::{.callout-warning icon=false}
Узнайте, все ли предложения в sentences (входит в stringr) кончаются на точку.
:::

</br>

## Квантификация

Квантификатор после символа, символьного класса или группы определяет, сколько раз предшествующее выражение может встречаться. Квантификатор может относиться более чем к одному символу в регулярном выражении, только если это символьный класс или группа.

| Представление |	Число повторений |	Эквивалент |	
| --------------| -----------------| ------------| 
| ? 	| Ноль или одно |	{0,1} 	|
| * 	| Ноль или более |	{0,} 	|
| + 	| Одно или более |	{1,} 	|

Пример:

```{r}
vec <- c("color", "colour", "colouur")
str_detect(vec, "ou?r") # ноль или одно 
str_detect(vec, "ou+r") # одно или больше
str_detect(vec, "ou*r") # ноль или больше
```

Точное число повторений (интервал) можно задать в фигурных скобках:

| Представление |	Число повторений 	|
| ------------- | ----------------  |
| {n} |	Ровно n раз 	|
| {m,n} |	От m до n включительно 	|
| {m,} |	Не менее m 	|
| {,n} |	Не более n |

```{r}
vec <- c("color", "colour", "colouur", "colouuuur")
str_detect(vec, "ou{1}r")
str_detect(vec, "ou{1,2}r")
str_detect(vec, "ou{0,2}r") # это включает и ноль!
```

Часто используется последовательность `.*` для обозначения любого количества любых символов между двумя частями регулярного выражения. 


:::{.callout-warning icon=false}
Узнайте, в каких предложениях в sentences за пробелом следует ровно три согласных.
:::

## Жадная и ленивая квантификация

В регулярных выражениях квантификаторам соответствует максимально длинная строка из возможных (квантификаторы являются жадными, англ. greedy). Это может оказаться значительной проблемой. Например, часто ожидают, что выражение `<.*>` найдёт в тексте теги HTML. Однако если в тексте есть более одного HTML-тега, то этому выражению соответствует _целиком строка, содержащая множество тегов_.

```{r}
vec <- c("<p><b>Википедия</b> — свободная энциклопедия, в которой <i>каждый</i> может изменить или дополнить любую статью.</p>")
str_remove(vec, "<.*>") # все исчезло!
```

Чтобы этого избежать, надо поставить после квантификатора знак вопроса. Это сделает его ленивым.

| regex |	значение |
| ------ | -------- |
| ?? |	0 или 1, лучше 0 |
| *? | 	0 или больше, как можно меньше |
| +? |  1 или больше, как можно меньше |
| {n,m}? |	от n до m, как можно меньше |

Пример:

```{r}
str_remove_all(vec, "<.*?>") # все получилось!
```

:::{.callout-warning icon=false}
Дана строка "tomorrow (and) tomorrow (and) tomorrow". Необходимо удалить первые скобки с их содержанием. 
:::


## str_length() и str_c()

Вот так можно узнать длину строки или объединить ее с другими строками:

```{r}
vec <- c("жираф", "верблюд")
str_length(vec)
str_c("красивый_", vec)
```

Элементы вектора можно объединить в одну строку:

```{r}
str_c(vec, collapse = ", ") # теперь у них общие кавычки
```

## str_sub() и str_sub_all()

С помощью str_sub() и str_sub_all() можно выбрать часть строки.

```{r}
vec <- c("жираф", "верблюд")
str_sub(vec, 1, 3)
str_sub(vec, 1, -2)
```

## Смена регистра

Функции ниже меняют начертание с прописного на строчное или наоборот:

```{r}
str_to_upper(vec)
str_to_lower("HELP")
str_to_title(vec)
```

Одна из полезнейших функций в этом пакете – `str_view()`; она помогает увидеть, что поймало регулярное выражение – до того, как вы внесете какие-то изменения в строку.

```{r}
str_view(c("abc", "a.c", "bef"), "a\\.c")
```


:::{.callout-warning icon=false}:::
Создайте тиббл с двумя столбцами: letters и numbers (1:26). Преобразуйте, чтобы в третьем столбце появился результат соединения первых двух через подчеркивание, например a_1. Отфильтруйте, чтобы остались только ряды, где есть цифра 3 или буква x.
:::

## Сумма и среднее

```{r}
library(rcorpora)
data("fruit")
head(fruit)
str_detect(head(fruit), "[aeiou]$")
# какая доля слов заканчивается на гласный?
mean(str_detect(fruit, "[aeiou]$"))
# сколько всего слов заканчивается на гласный?
sum(str_detect(fruit, "[aeiou]$"))
```

## Отрицание

Отрицание можно задать двумя способами:

```{r}
data("words")

no_vowels1 <- !str_detect(words, "[aeiou]") # слова без гласных

no_vowels2 <- str_detect(words, "^[^aeiou]+$") # слова без гласных

sum(no_vowels1 != no_vowels2)
```

Логический вектор можно использовать для индексирования:

```{r}
words[!str_detect(words, "[aeiou]")]
```

Эту функцию можно применять вместе с функцией `filter()` из пакета `dplyr`:

```{r}
library(rcorpora)
gods <- corpora(which = "mythology/greek_gods")

df <- tibble(god = as.character(gods$greek_gods), 
             i = seq_along(god)
             )

df |> 
  filter(str_detect(god, "s$"))
```

Вариацией этой функции является `str_count()`:

```{r}
str_count(as.character(gods$greek_gods), "[Aa]")
```

Эту функцию удобно использовать вместе с `mutate()` из `dplyr`:

```{r}
df |> 
  mutate(
    vowels = str_count(god, "[AEIOYaeiou]"),
    consonants = str_count(god, "[^AEIOYaeiou]")
  )
```


:::{.callout-warning icon=false}:::
Преобразуйте sentences из пакета `stringr` в тиббл; в новом столбце сохраните количество пробелов в каждом предложении.
:::

## str_extract(), str_subset() и str_match()

Функция `str_extract()` извлекает совпадения.

Сначала зададим паттерн для поиска.

```{r}
colours <- c(" red", "orange", "yellow", "green", "blue", "purple")
colour_match <- str_c(colours, collapse = "|")
colour_match
```

И применим к предложениями. Используем `str_extract_all()`, т.к. `str_extract()` возвращает только первое вхождение.

```{r}
has_colour <- str_subset(sentences, colour_match)
matches <- str_extract_all(has_colour, colour_match)
head(unlist(matches))
```

Круглые скобки используются для группировки. Например, мы можем задать шаблон для поиска существительного или прилагательного с артиклем.

```{r}
noun <- "(a|the) ([^ ]+)" # как минимум один непробельный символ после пробела

has_noun <- sentences |>
  str_subset(noun) |>
  head(10)
has_noun
```

Дальше можно воспользоваться уже известной функцией `str_extract()` или применить `str_match`. Результат будет немного отличаться: вторая функция вернет матрицу, в которой хранится не только сочетание слов, но и каждый компонент отдельно.

```{r}
has_noun |> 
  str_extract(noun)

has_noun |> 
  str_match(noun)
```

:::{.callout-warning icon=false}:::
Найдите в sentences все предложения, где есть to, и выберите следующее за этим слово. Переведите в нижний регистр. Узнайте, сколько всего уникальных сочетаний.
:::

## Диакритика

Мы уже знаем, что функции str_replace() и str_replace_all() позволяют заменять совпадения на новые символы. Этим можно воспользоваться, если вы хотите, например, удалить из текста все греческие символы. Для стандартного греческого алфавита хватит [Α-Ωα-ω], но для древнегреческого этого, например, не хватит. Попробуем на отрывке из письма Цицерона Аттику, которое содержит греческий текст.

```{r}
cicero <- "nihil hāc sōlitūdine iūcundius, nisi paulum interpellāsset Amyntae fīlius. ὢ ἀπεραντολογίας ἀηδοῦς! "

str_replace_all(cicero, "[Α-Ωα-ω]", "")
```

ὢ ἀί ἀῦ! Не все у нас получилось гладко. Попробуем иначе:

```{r}
str_replace_all(cicero, "[\u0370-\u03FF]", "")
```

Удалилась (буквально была заменена на пустое место) та диакритика, которая есть в новогреческом (ί). Но остались еще буквы со сложной диакритикой, которой современные греки не пользуются.

```{r}
no_greek <- str_replace_all(cicero, "[[\u0370-\u03FF][\U1F00-\U1FFF]]", "")
no_greek
```

! Мы молодцы. Избавились от этого непонятного греческого.

На самом деле, конечно, `str_replace` хорош тем, что он позволяет производить осмысленные замены. Например, мы можем в оставшемся латинском текст заменить гласные с макроном (черточка, означающая долготу) на обычные гласные.

```{r}
str_replace_all(no_greek, c("ā" = "a", "ū" = "u", "ī" = "i", "ō" = "o"))
```

## str_split()

Функция `str_split()` помогает разбить текст на предложения, слова или просто на бессмысленные наборы символов. Это важный этап подготовки текста для анализа, и проводится он нередко именно с применением регулярных выражений.

```{r}
sentences |>
  head(2) |> 
  str_split(" ")
```

Но можно обойтись и без регулярных выражений.

```{r}
x <- "This is a sentence.  This is another sentence."
str_view_all(x, boundary("word"))
str_view_all(x, boundary("sentence"))
```


Очень удобно, но убедитесь, что в вашем языке границы слов и предложения выглядят как у людей. С древнегреческим эта штука не справится (как делить на предложения греческие и латинские тексты, я рассказывала здесь):

```{r}
apology <- c("νῦν δ' ἐπειδὴ ἀνθρώπω ἐστόν, τίνα αὐτοῖν ἐν νῷ ἔχεις ἐπιστάτην λαβεῖν; τίς τῆς τοιαύτης ἀρετῆς, τῆς ἀνθρωπίνης τε καὶ πολιτικῆς, ἐπιστήμων ἐστίν; οἶμαι γάρ σε ἐσκέφθαι διὰ τὴν τῶν ὑέων κτῆσιν. ἔστιν τις,” ἔφην ἐγώ, “ἢ οὔ;” “Πάνυ γε,” ἦ δ' ὅς. “Τίς,” ἦν δ' ἐγώ, “καὶ ποδαπός, καὶ πόσου διδάσκει;")

str_view_all(apology, boundary("sentence"))
```


Полный крах 💩
