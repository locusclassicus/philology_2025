# Нормализация и оценка 

Есть старая шутка, ее приписывают программисту Джейми Завински: если у вас есть проблема, и вы собираетесь ее решать при помощи регулярных выражений, то у вас две проблемы. Регулярные выражения -- это формальный язык, который используется для того, чтобы находить, извлекать и заменять части текста. Мы воспользуемся регулярными выражениями для того, чтобы привести в порядок распознанный текст.

Для работы нам понадобится пакет `stringr` из библиотеки `tidyverse`.

```{r message=FALSE}
library(tidyverse)
```

Загрузим распознанный текст элегии. 

```{r}
text <- readLines(con = "../ocr/rosalia_1.txt")
text
```
:::{.callout-note icon=false}:::
Чаще всего используемые в дореформенной русской орфографии:

- Ять: Ѣ (U+0462), ѣ (U+0463)
- И десятеричное: І (U+0406), і (U+0456)
- Фита: Ѳ (U+0472), ѳ (U+0473)
- Ижица: Ѵ (U+0474), ѵ (U+0475)
- Твёрдый знак, еръ: Ъ (U+042A), ъ (U+044A)
:::


## Литералы и классы

Регулярные выражения (regex, regexp) объединяют _буквальные символы_ (литералы) и _метасимволы_ (символы-джокеры, англ. wildcard characters). 

Для поиска используется строка-образец (англ. pattern, по-русски её часто называют "шаблоном", "маской"), которая задает правило поиска. Строка замены также может содержать в себе специальные символы. 


:::{.callout-note icon=false}
Отличный путеводитель по миру регулярных выражений в R можно найти [здесь](https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html).
:::


_Буквальные символы_ -- это то, что вы ожидаете увидеть (или не увидеть -- для управляющих и пробельных символов); можно сказать, что это символы, которые ничего не "имеют в виду". Их можно объединять в _классы_ при помощи квадратных скобок.  

Для поиска совпадений используются три функции: `str_detect()`, `str_which()` и `str_subset()`. Первая возвращает логический вектор (то есть вектор значений `TRUE` / `FALSE`); вторая -- индексы элементов, а третья -- сами эти элементы. Сравним.

```{r}
# возвращает логический вектор
str_detect(text, "[ѣъ]")
```

Так мы нашли все строки, где есть еры или яти. Можно сохранить логический вектор и использовать его для индексации. Функция `head()` позволяет ограничить вывод первыми элементами вектора.

```{r eval=FALSE}
# создаем индекс
idx <- str_detect(text, "[ѣъ]")

# используем его для отбора строк
text[idx] 
```

Теперь узнаем, в каких строках находятся рядом буквы ія. Мы не объединяем их в класс при помощи квадратных скобок, поэтому фукнция ищет не что-то одно, а именно сочетание.

```{r}
str_which(text, "ія")
```

Эту функцию тоже можно использовать для индексации. На этот раз не сохраняем переменную `idx`. 

```{r}
text[str_which(text, "ія")]
```

Наконец, `str_subset()` сама индексирует вектор. Попробуем.

```{r}
str_subset(text, "i")
```

Упс. Что произошло, куда делись все i? Дело в том, что я набрала i в латинской клавиатуры, а это другой знак в Юникоде. Проверим (первую i копирую из текста выше):

```{r}
"і" == "i"
```

Исправляем. 

```{r}
str_subset(text, "і")
```
В некоторых случаях удобнее использовать непосредственно код буквы. 

```{r}
str_subset(text, "[\u0406\u0456]")
```
Обратите внимание, что у прописных и строчных букв свои коды, и в предыдущем случае мы упустили строку с буквой І. 



Для некоторых классов есть специальные обозначения.

|Класс | Эквивалент | Значение|
|----- | ------- | -----|
| [:upper:] |	[A-Z] |	Символы верхнего регистра |
| [:lower:] |	[a-z] |	Символы нижнего регистра |
| [:alpha:] |	[[:upper:][:lower:]] |	Буквы |
| [:digit:] |	[0-9], т. е. \\d  |	Цифры |
| [:alnum:] |	[[:alpha:][:digit:]] |	Буквы и цифры |
| [:word:] 	| [[:alnum:]], т. е. \\w |	Символы, образующие «слово» |
| [:punct:] |	[-!"#$%&'()*+,./:;<=>?@[\\\]_`{\|}~] |	Знаки пунктуации |
| [:blank:] |	[\\s\\t] |	Пробел и табуляция |
| [:space:] |	[[:blank:]\\v\\r\\n\\f], т. е. \\s |	Пробельные символы |
|[:cntrl:] |	 |	Управляющие символы (перевод строки, табуляция и т.п.) |
| [:graph:] |	 |	Печатные символы |
| [:print:] |	 |	Печатные символы с пробелом |

Эти классы тоже можно задавать в качестве паттерна.

```{r}
# заменяет все вхождения
str_subset(text, "[[:digit:]]")
```

Работы с регулярными выражениями требует навыка; поначалу, прежде чем преобразовывать строки, удобно просто посмотреть, что попало в ваш невод. 

```{r results='asis'}
str_view(text[1:8], "[[:punct:]]", html = TRUE)
```

Внутри квадратных скобор знак `^` означает отрицание. Сравните:

```{r}
# удаляем всю пунктуацию
str_remove_all(text[1:8], "[[:punct:]]") 
```

```{r}
# удаляем все, кроме пунктуации
str_remove_all(text[1:8], "[^[:punct:]]") 
```



В качестве классов можно рассматривать и следующие обозначения:

| Представление |	Эквивалент | 	Значение |
|-------------- | ---------- | ----------|
| \\d |	[0-9] |	Цифра |
| \\D |	[^\\d] |	Любой символ, кроме цифры |
| \\w |	[A-Za-zА-Яа-я0-9_] |	Символы, образующие «слово» (буквы, цифры и символ подчёркивания) |
| \\W |	[^\\w] |	Символы, не образующие «слово» |
| \\s |	[ \\t\\v\\r\\n\\f] |	Пробельный символ |
| \\S |	[^\\s] |	Непробельный символ |


Найдем все строки с числами и удалим их (в нашем случае либо номера страниц, либо ошибки распознавания). Также удалим все пустые строки.

```{r}
# вторая косая черта "экранирует" первую
text2 <- text[!str_detect(text, "\\d") & nchar(text) != 0]
text2
```


Теперь удалим лишние пробелы и заменим яти на е. Функция `str_replace()` заменяет только первое вхождение в каждом элементе вектора, поэтому в строке 16 осталось "привѣтъ" (ср. 17, 18 и 21).

```{r}
text2 |> 
  str_squish() |> 
  str_replace("ѣ", "е")
```

Чтобы заменить все вхождения, используем `str_replace_all()`. Можно произвести сразу несколько замен, задав вектор соответствий:

```{r}
text3 <- text2 |> 
  str_squish() |> 
  str_replace_all(c("і" = "и", "ѣ" = "е"))
```

:::{.callout-warning icon=false}
В пакете `stringr` есть небольшой датасет `words`. Найдите все слова с последовательностью символов wh.  Сколько слов содержат два гласных после w? Найдите все слова в `words`, в которых за w следует согласный. Замените всю пунктуацию в строке "tomorrow?and-tomorrow_and!tomorrow" на пробелы.
:::


## Якоря и квантификация

Якоря позволяют искать последовательности символов в начале или в конце строки. Знак `^` (вне квадратных скобок!) означает начало строки, а знак `$` -- конец. Мнемоническое правило: First you get the power (^) and then you get the money ($). 

```{r}
str_subset(text3, ",$")
```

```{r}
str_subset(text3, ",$")
```

Найдем строки, которые начинаются со строчной:

```{r}
str_subset(text3, "^[а-я]")
```


Теперь найдем все строки, в которых больше одного знака пунктуации или пробела  в конце. Для этого нам нужны не только якоря, но и _квантификаторы_. Квантификатор после символа, символьного класса или группы определяет, сколько раз предшествующее выражение может встречаться. 


| Представление |	Число повторений |	Эквивалент |	
| --------------| -----------------| ------------| 
| ? 	| Ноль или одно |	{0,1} 	|
| * 	| Ноль или более |	{0,} 	|
| + 	| Одно или более |	{1,} 	|


Точное число повторений (интервал) можно задать в фигурных скобках:

| Представление |	Число повторений 	|
| ------------- | ----------------  |
| {n} |	Ровно n раз 	|
| {m,n} |	От m до n включительно 	|
| {m,} |	Не менее m 	|
| {,n} |	Не более n |

```{r}
str_subset(text3, "\\W{2,}$")
```

:::{.callout-warning icon=false}
Узнайте, в каких предложениях в sentences за пробелом следует ровно три согласных. Найдите все слова в `words`, которые заканчиваются на x. Найдите все слова, которые начинаются на b или на g.
:::


## Метасимволы и экранирование 

Все метасимволы представлены в таблице ниже.

| Описание |	Символ |
| ---------| --------| 
|открывающая квадратная скобка |	[ |
|закрывающая квадратная скобка |	] |
|обратная косая черта |	\\ |
|карет |	^ |
|знак доллара |	$ |
|точка |	. |
|вертикальная черта |	\| |
|знак вопроса |	? |
|астериск |	* |
|плюс |	+ |
|открывающая фигурная скобка |	\{ |
|закрывающая фигурная скобка |	\} |
|открывающая круглая скобка |	( |
|закрывающая круглая скобка	| ) |

Квадратные скобки используются для создания классов, карет и знак доллара -- это якоря, но карет внутри квадратных скобок может также быть отрицанием. Точка -- это любой знак. 

```{r}
# любой символ после знака вопроса
str_subset(text3, "\\?.") 
```

Две косые черты перед знаком вопроса означают _экранирование_. Оно используется тогда, когда  необходимо найти буквальную точку, буквальный знак вопроса и т.п., т.е. превратить метасимвол в литерал. Для этого перед знаком ставится косая черта. Но так как сама косая черта -- это метасимвол, но нужно две косые черты, первая из которых экранирует вторую.


Часто используется последовательность `.*` для обозначения любого количества любых символов между двумя частями регулярного выражения. Вот так находим любой знак между двумя (буквальными) точками:

```{r}
str_extract(text3, "\\..\\.")
```

Вот так -- любое число знаков между двумя точками. 

```{r}
str_extract(text3, "\\..*\\.")
```

В регулярных выражениях квантификаторам соответствует максимально длинная строка из возможных (квантификаторы являются _жадными_, англ. greedy). Чтобы этого избежать, надо поставить после квантификатора знак вопроса. Это сделает его _ленивым_.

| regex |	значение |
| ------ | -------- |
| ?? |	0 или 1, лучше 0 |
| *? | 	0 или больше, как можно меньше |
| +? |  1 или больше, как можно меньше |
| {n,m}? |	от n до m, как можно меньше |

Пример:

```{r}
str_extract(text3, "\\..*?\\.")
```

:::{.callout-warning icon=false}
Дана строка "tomorrow (and) tomorrow (and) tomorrow". Необходимо удалить первые скобки с их содержанием. Узнайте, все ли предложения в sentences (входит в stringr) кончаются на точку. Найдите все слова в `words`, в которых есть любые два символа между b и k.
:::

## Группировка и Look arounds

Допустим, мы нашли несколько подряд знаков препинания и пробелов и хотим удалить лишние. Это можно сделать при помощи группировки 

```{r}
text4 <- text3 |> 
  # чтобы не потерять тире в конце строки
  str_replace(" —$", "—") |> 
  str_replace("(\\W)(\\W+)$", "\\1")

text4
```

Нам осталось удалить твердые знаки в конце слов (то есть перед пробелами, пунктуацией или в конце строки). Используем для этого так называемые look arounds. 


| Запись        | Название на русском          | Описание                                                                                                  |
|---------------|-----------------------------|-----------------------------------------------------------------------------------------------------------|
| `(?=...)`     | Положительный просмотр вперёд | Совпадает, если ... находится в текущей позиции (но не захватывает его в результат).                      |
| `(?!...)`     | Отрицательный просмотр вперёд | Совпадает, если ... не находится в текущей позиции (не захватывает в результат).                      |
| `(?<=...)`    | Положительный просмотр назад  | Совпадает, если ... находится сразу перед текущей позицией (длина ... должна быть ограниченной).           |
| `(?<!...)`    | Отрицательный просмотр назад  | Совпадает, если ... не находится сразу перед текущей позицией (длина ... должна быть ограниченной). |



```{r results='asis'}
str_view(text4, "[ъЪ](?=\\W)", html = TRUE)
```

Теперь удалим такие знаки препинания, которые следуют за другими знаками препинания в конце строки. Также добавим в контекст сам конец строки (иначе остается с твердым знаком слово "отлетает").

```{r}
text5 <- str_remove_all(text4, "[ъЪ](?=\\W|$)")
text5
```

## Оборачиваем в функцию 

```{r}
normalize_text <- function(text) {
  # подумайте, нужно ли вам удалять строки с цифрами!
  text[!str_detect(text, "\\d") & nchar(text) != 0] |> 
    str_squish() |> 
    str_replace_all(c("і" = "и", "ѣ" = "е")) |>
    str_replace(" —$", "—") |> 
    str_replace("(\\W)(\\W+)$", "\\1") |> 
    str_remove_all("[ъЪ](?=\\W|$)")
}

normalize_text(text)
```



