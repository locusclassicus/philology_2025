# Распознавание изображений

В этом уроке мы освоим основной инструмент для распознавания печатного текста в R – пакет `tesseract`, а также научимся дообучать модели под конкретные задачи и шрифты. Для работы нам понадобятся следующие библиотеки:

```{r}
library(qpdf)
library(tesseract)
library(pdftools)

# install.packages("remotes")
remotes::install_github("arcruz0/tesseractgt")
library(tesseractgt)
```

## Что такое OCR и tesseract

OCR (Optical Character Recognition) — это технология автоматического распознавания печатного текста на изображениях и преобразования его в машинно-читаемый формат. Эта технология позволяет “извлекать” текст из сканированных документов, фотографий, PDF-файлов и других графических форматов.

[Tesseract](https://ru.wikipedia.org/wiki/Tesseract) — это одна из самых популярных библиотек OCR с открытым исходным кодом, разработанная компанией Google. Tesseract поддерживает более 100 языков и может работать с различными типами изображений и форматами документов.

Пакет `tesseract` в R представляет собой обертку для библиотеки Tesseract, которая позволяет:

- Распознавать текст с изображений различных форматов (PNG, JPEG, TIFF, PDF);
- Работать с многостраничными документами;
- Использовать предобученные модели для разных языков; ([список](https://tesseract-ocr.github.io/tessdoc/Data-Files-in-different-versions.html));
- Настраивать параметры распознавания под конкретные задачи;
- Дообучать модели для улучшения качества распознавания специфических шрифтов или типов документов.

В отличие от онлайн-сервисов OCR, пакет `tesseract` работает локально, что обеспечивает:

- Конфиденциальность — данные не передаются третьим лицам;
- Скорость — нет задержек на передачу данных по сети;
- Настраиваемость — возможность тонкой настройки под конкретные задачи;
- Бесшовную интеграцию с экосистемой R для дальнейшего анализа данных.

Однако качество распознавания сильно зависит от качества исходного изображения, типа шрифта, языка документа и правильности настройки параметров. Именно поэтому важно уметь не только использовать готовые модели, но и дообучать их под специфические задачи.

```{r}
```

## Данные

В качестве упражнения мы возьмем ч. 6 № 6 журнала “Невский зритель” за 1821 г. ([источник](http://lib.pushkinskijdom.ru/Default.aspx?tabid=11373)).

Журнал «Невский зритель» издавался в Петербурге ежемесячно с января 1820 г. по июнь 1821 г. Всего вышло 18 книжек журнала, составивших 6 частей. Все они доступны на сайте “Пушкинского дома”.

> Официальным издателем журнала был выпускник Московского университета Иван Матвеевич Сниткин (род. ок. 1792 г.). С января по апрель 1820 г. соиздателем «Невского зрителя» был В. К. Кюхельбекер; намеревался войти в число издателей и К. Ф. Рылеев (1797-1826), активный сотрудник журнала с октября 1820-го по февраль 1821 г. В разное время в журнале печатались произведения Пушкина, Кюхельбекера, Жуковского, Баратынского, Дельвига, а также Рылеева, поместившего в октябрьской книжке 1820 г. острейшую сатиру на Аракчеева «К временщику». ([Источник](https://www.gorkilib.ru/events/200-let-zhurnalu-nevskiy-zritel).)

## Выбор страниц

Для начала вырежем несколько страниц из pdf. Таким образом вы легко можете делить любые издания на главы, разделы и т.д.

```{r}
my_files <- list.files("../ocr", pattern = "pdf", full.names = TRUE)
my_files[2] # нужный файл
```

```{r eval=FALSE}
pdf_subset(input = my_files[2],
           output = "../ocr/НЗ1821_6_6[50-51].pdf",
           pages = 50:51)
```


:::{layout-ncol=2}

![](./images/rosalia1.png)

![](./images/rosalia2.png)

:::

:::{.callout-tip icon=false}
Найдите в метаданных к корпусу русских элегий предположительную фамилию автора.
:::

Ответ: `r fitb("Бадульф")`.

## Извлечение текста из pdf

Если вам повезло, то pdf хранит уже распознанный текст.

```{r}

text1 <- pdf_text(pdf = "../ocr/НЗ1821_6_6[50-51].pdf")
cat(text1)
```


Текст распознан достаточно хорошо, есть мелкие ошибки, но их можно исправить (о чем речь пойдет в следующем уроке). Если необходимо сохранить извлеченный из pdf текст для дальнейшей работы, это делается так:

```{r eval=FALSE}
writeLines(text1, con = "../ocr/rosalia.txt")
```

## Распознавание

Если текст не распознан (притворимся, что так и есть), то можно попробовать распознать при помощи `tesseract`. Однако есть нюанс: `tesseract` не знает дореформенного русского. Это значит, что все яти (ѣ), еры (ъ), фиты (Ѳ) и десятеричные и (і) превратятся во что-то странное. А еще трудности бывают с буквой "т", т.к. в XIX в. ее печатали по-другому.

Проверим. Но прежде всего надо скачать модель для русского языка. Это делается один раз. Кстати, тессеракт способен "читать" тексты на нескольких языках, для этого передаем значение аргументу language так: `"rus+deu"`.

```{r eval=FALSE}
# tesseract_download("rus")
tesseract_info()$available
```

```{r}
text2 <- pdf_ocr_text("../ocr/НЗ1821_6_6[50-51].pdf", 
                      language = "rus")

cat(text2)

# Converting page 1 to НЗ1821_6_6[50-51]_1.png... done!
# Converting page 2 to НЗ1821_6_6[50-51]_2.png... done!

# 999939993993999999339993399999939939 9039303939
# РАЗЛУКА.
# (Элегтя.)
# ————-
# Розамя, мой спушникъь неизмённый
# На полЪ радосшей земныхь!
# Розал!я, мой другь, хранишель несравненный!
# Когда я ошдохну въ объяпияхь швоихъ?...
# Съ шобою горестей душа моя незнаеть,
# И сердцу скорбному не измЪнить покой!
# Надежда мрачный пушь звЪздою озаряепть,
# И я мирюсь съ враждебною судьбой!...
# ’Геперь, за дальними, свиофпыми морями
# Твой сладк!й гласъ не оживишьъ меня!
# Взойдеть заря надъ злачными холмами,
# Появишся въ лучахъ свЪшило дня —
# Напрасно! все кругомъ покрыпю мглою.
# Неслышишся мнЪ сладюй тивой привЪфить,
# ВсЪ5 радосши, надежды всЪ съ шобою —
# И опусш$ль безъ милой свЪзить’
# Подруга милая, скажи, чшо край прелесшный,
# Чпо мирвыя, тифвисптыя поля,
# Чтпо своенравныя судьбы привЪтьъ мн лесшный,
# Когда съ шобой въ разлук я.
# Но другь мой! горесмь ошленаепть
#  245
# На бысшрыхь времени крылахь,
# И радосшь сердце посфщаеть....
# Моя надежда — въ небесахь!...
# Когдажъ опяшь смягченными судьбами
# Я въ радосши къ подругЪ понесусь,
# Коснусь волшебныхь сшрунь волшебными пер-
# сшами
# И, сь рфзвою мечтшою примирюсь.
# Я, Б — $5.
```

Что в таких случаях делать?

- Первое: проверить, нет ли обученных моделей, которые справятся с вашей задачей. Можно поискать, например, [модели](https://huggingface.co/Serovvans/trocr-prereform-orthography) на Hugging Face. Но результат может будет зависеть от того, на каких шрифтах учили модель.

- Второе: обученные модели можно также поискать в [Транскрибусе](https://sysblok.ru/digital-heritage/transkribus-kak-kompjuternoe-zrenie-pomogaet-perevodit-teksty-sirijskih-mistikov/) (например, [здесь](https://app.transkribus.org/models/public/text/russian-print-xviii-cent) и [здесь](https://app.transkribus.org/models/public/text/44358)). Но у Транскрибуса есть ряд ограничений: модели нельзя использовать локально, расширенный функционал платный, и др. Бесплатно можно пользоваться готовыми приложениями; однако сначала pdf придется преобразовать в картинку. 

```{r eval=FALSE}
pdf_convert("../ocr/НЗ1821_6_6[50-51].pdf", 
            format = "png", 
            dpi = 300,
            pages = NULL,  # все страницы, или c(1,3,5) для конкретных
            filenames = NULL)
```


- Наконец, можно дообучить уже существующую модель `tesseract`, как показано вот в этом [примере](https://arcruz0.github.io/posts/finetuning-tess/index.html). Этим мы сейчас и займемся.

## Файн-тюнинг

Начиная с версии 4, Tesseract использует нейронную сеть для распознавания текста, что позволяет дообучать модель для конкретных задач. Для дообучения необходимы эталонные данные — фрагменты изображений с соответствующим им текстом.

### Подготовка изображений

Создайте папку с именем `{язык}-ground-truth/` (например, `orus-ground-truth/`) и поместите туда изображения текста. Названия файлов могут быть любыми. Самый простой способ: сделать скриншоты вручную (чем больше, тем лучше). Вот пример:

![](images/ground_truth1.png)

Более продвинутый подход к нарезке изображений можно найти [здесь](https://github.com/ukolshurika/finetune-ocr-sample) (для Python). Мы нарежем изображение на отдельные слова в R. Для этого скачайте следующий [скрипт](https://github.com/locusclassicus/philology_2025/blob/main/helper_scripts/crop_words.R) и запустите его:

```{r}
source("../helper_scripts/crop_words.R")
```

В глобальном окружении появится функция `crop_words()`. Она принимает на входе путь до изображения (обязательный аргумент), название директории, куда будут сохранены слова (по умолчанию `words`), язык базовой модели (код `tesseract`, по умолчанию `rus`) и отступ вокруг слова при обрезке (в пикселях). Аргумент `overwrite` управляет тем, очищать ли существующие файлы `word_*.png` в `out_dir` перед сохранением (по умолчанию `FALSE`). 

Также функция проверяет наличие пакетов `magick`, `tesseract`, `tidyverse`; при отсутствии пытается установить их вместе с зависимостями и затем подключает.
Для корректной работы OCR с выбранным языком в системе должны быть установлены языковые данные Tesseract.

```{r}
crop_words(image_path = "../ocr/НЗ1821_6_6[50-51]_1.png",
           out_dir = "../ocr/words",
           lang = "rus",
           pad = 2L,
           overwrite = FALSE)
```

После этого в папке `words` должно появиться нечто похожее:

![](images/words_view.png)
Чтобы "разрезать" на слова _несколько_ изображений, используем функции для итераций из пакета `purrr` (мы встречались с ними, когда читали сразу несколько текстовых файлов в окружение).

```{r}
img_paths <- list.files("../ocr", pattern = "png", full.names = TRUE)
img_paths
```

```{r eval=FALSE}
walk(img_paths, crop_words, 
     out_dir = "../ocr/orus-ground-truth")
```

### Текстовые файлы

Теперь для каждого изображения добавим текст (файлы в формате `.gt.txt`). Для ускорения процесса создания эталонных файлов можно использовать пакет `tesseractgt`. Для создания таких файлов используем базовую модель.

```{r eval=FALSE}
create_gt_txt(
  folder = "../ocr/orus-ground-truth",
  extension = "png", 
  engine = tesseract::tesseract(language = "rus")
)
```

Убедитесь, что файлы появились в директории. Список должен выглядеть примерно так:

![](images/img_and_text_view.png)
   

Теперь самый важный этап: корректировка текстовых файлов. Исправить автоматически созданные файлы `.gt.txt` поможет специальная функция:

```{r eval=FALSE}
correct_gt_txt() 
```

![[Источник](https://arcruz0.github.io/posts/finetuning-tess/)](https://arcruz0.github.io/posts/finetuning-tess/imgs/addin.gif)

Если не видно папки с изображениями, смените рабочую директорию. Вот несколько полезных символов: 

:::{.callout-note icon=false}:::
Чаще всего используемые в дореформенной русской орфографии:

- Ять: Ѣ (U+0462), ѣ (U+0463)
- И десятеричное: І (U+0406), і (U+0456)
- Фита: Ѳ (U+0472), ѳ (U+0473)
- Ижица: Ѵ (U+0474), ѵ (U+0475)
- Твёрдый знак, еръ: Ъ (U+042A), ъ (U+044A)

:::

###  Дообучение

Теперь мы готовы к дообучению модели. Сначала переходим в терминал, клонируем репозиторий `tesstrain`: 

```{r eval=FALSE}
git clone https://github.com/tesseract-ocr/tesstrain.git
```

Эта команда скачает репозиторий `tesstrain` с GitHub. При этом локально создается папка `tesstrain` со скриптами и `Makefile` для обучения моделей Tesseract. Скачивание может занять несколько минут.

Теперь переходим в только что созданную папку. Команда смены каталога `cd` работает и на macOS, и на Windows.

```{r eval=FALSE}
cd tesstrain
```

Следующая команда запускает утилиту (небольшую программу) `make` и выполняет задачу `tesseract-langdata`, описанную в `Makefile` проекта. В результате автоматически скачиваются официальные языковые данные Tesseract, необходимые для обучения, а именно `langdata` и/или `langdata_lstm` — наборы текстов, списки слов, правила пунктуации/нормализации и прочие файлы, которые используются при подготовке и обучении модели.

```{r eval=FALSE}
make tesseract-langdata
```

На этом этапе вы можете столкнуться с ошибкой. 

```{r eval=FALSE}
# Makefile:175: *** This version of GNU Make is too low (3.81). Check your path, or upgrade to 4.2 or newer..  Stop.
```

Проблема решается путем обновления утилиты. На MacOS установить новую GNU Make можно через Homebrew (это менеджер пакетов, его надо отдельно устанавливать: <https://brew.sh/>):

```{r eval=FALSE}
# в терминале
brew install make
```

После установки появится команда `gmake`. Её можно вызывать напрямую:

```{r eval=FALSE}
# в терминале, придется подожать
gmake tesseract-langdata
```

На Windows задача также решается при помощи менеджера пакетов -- например, Scoop <https://scoop.sh/>.

```{r eval=FALSE}
# в терминале
scoop install make
```

После установки проверьте версию `make`.

```{r eval=FALSE}
# в терминале 
# gmake --version для MacOS
make --version
```

Итог: после этих команд у вас есть локальная копия `tesstrain`, вы находитесь в её каталоге, и в него загружены исходные языковые данные (`data`), без которых обучение своей модели Tesseract не запустится. 

На этом этапе структура каталога выглядит так:

```{r echo=FALSE, eval=FALSE}
library(fs)
fs::dir_tree(path = "../tesstrain",
             recurse = TRUE)

# ../tesstrain
# ├── LICENSE
# ├── Makefile
# ├── README.md
# ├── count_chars.py
# ├── data
# │   └── langdata
# │       ├── Arabic.unicharset
# │       ├── Armenian.unicharset
# │       ├── Bengali.unicharset
# │       ├── ...
# │       └── radical-stroke.txt
# ├── generate_eval_train.py
# ├── generate_gt_from_box.py
# ├── generate_line_box.py
# ├── generate_line_syllable_box.py
# ├── generate_wordstr_box.py
# ├── normalize.py
# ├── ocrd-testset.zip
# ├── ocrd.plot_cer.png
# ├── plot_cer.py
# ├── plot_log.py
# ├── requirements.txt
# ├── shuffle.py
# └── src
#     ├── README.md
#     ├── setup.cfg
#     ├── setup.py
#     └── tesstrain
#         ├── __init__.py
#         ├── __main__.py
#         ├── arguments.py
#         ├── generate.py
#         ├── language_specific.py
#         └── wrapper.py
``` 

Теперь нам надо переместить обучающие данные -- в нашем случае это `orus-ground-truth` в папку `data`. Можете просто скопировать вручную.

Все, можно запускать дообучение. 

```{r eval=FALSE}
# в терминале, make на Windows
gmake training MODEL_NAME=orus START_MODEL=rus FINETUNE_TYPE=Impact LANG_TYPE=Both
```

Команда выше запускает "рецепт" обучения нейросети Tesseract. Этот рецепт под названием `training` автоматически готовит данные и запускает процесс дообучения модели распознавания текста.

Что означает каждая часть команды:

- `gmake training` — запустить задание `training` из файла правил (`Makefile`). Оно скачает/подготовит данные, запустит обучение и положит результат в папку с моделями.
- `MODEL_NAME=orus` — имя новой модели, которую вы хотите получить. В конце появится файл вроде `orus.traineddata`.
- `START_MODEL=rus` — не учить с нуля, а взять за основу существующую русскую модель `rus` и "докрутить" ее под новые данные. Это быстрее и надежнее.
- `FINETUNE_TYPE=Impact` — "бережное" дообучение: меняются только части сети, чтобы сохранить сильные стороны базовой модели и адаптировать её под ваши тексты.
- `LANG_TYPE=Both` — использовать оба набора языковых данных Tesseract (классический и LSTM), чтобы шире покрыть правила, словари и примеры. 

Дообучение занимает несколько минут ☕☕☕

### Установка модели

Найдите системную папку Tesseract:

```{r}
tesseract::tesseract_info()$datapath
```

Скопируйте сюда новую модель `orus.trainedata`, которая должна появиться в папке `data`.

Проверьте доступные модели:

```{r}
tesseract::tesseract_info()$available
```

Все, после дообучения можем использовать новую модель:

```{r}
text3 <- pdf_ocr_text("../ocr/НЗ1821_6_6[50-51].pdf", language = "orus")
```

Таким образом, дообучение Tesseract позволяет улучшить качество распознавания специализированных текстов; для лучшего результата используйте больше обучающих данных (чем больше, тем лучше). Пакет `tesseractgt` существенно упрощает процесс подготовки обучающих данных.

## Видео к этому уроку

```{r echo=FALSE}
library(cowsay)
say("Будет добавлено позже", "egret")
```

## Домашнее задание

```{r echo=FALSE}
say("Будет добавлено позже", "owl")
```