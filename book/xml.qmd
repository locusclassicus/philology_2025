# Разметка XML

```{r}
library(tidyverse)
```

XML (от англ. eXtensible Markup Language) --- расширяемый язык разметки. Слово "расширяемый" означает, что список тегов не зафиксирован раз и навсегда: пользователи могут вводить свои собственные теги и создавать так называемые _настраиваемые языки разметки_ [@xml2004, 29]. Один из таких настраиваемых языков -- это TEI (Text Encoding Initiative), о котором будет сказано дальше.

Назначение языков разметки заключается в описании структурированных документов. Структура документа представляется в виде набора вложенных в друг друга элементов (дерева XML). У элементов есть открывающие и закрывающие теги. 

Все составляющие части документа обобщаются в пролог и корневой элемент. Корневой элемент — обязательная часть документа, в которую вложены все остальные элементы. Пролог может включать объявления, инструкции обработки, комментарии.

В правильно сформированном XML открывающий и закрывающий тег вложенного элемента всегда находятся внутри одного родительского элемента.

Создадим простой XML из строки. Сначала идет инструкция по обработке XML (со знаком вопроса), за ней следует объявление типа документа (с восклицательным знаком) и открывающий тег корневого элемента. В этот корневой элемент вложены все остальные элементы.

```{r}
string_xml <- '<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE recipe>
<recipe name="хлеб" preptime="5min" cooktime="180min">
   <title>
      Простой хлеб
   </title>
   <composition>
      <ingredient amount="3" unit="стакан">Мука</ingredient>
      <ingredient amount="0.25" unit="грамм">Дрожжи</ingredient>
      <ingredient amount="1.5" unit="стакан">Тёплая вода</ingredient>
   </composition>
   <instructions>
     <step>
        Смешать все ингредиенты и тщательно замесить. 
     </step>
     <step>
        Закрыть тканью и оставить на один час в тёплом помещении. 
     </step>
     <step>
        Замесить ещё раз, положить на противень и поставить в духовку.
     </step>
   </instructions>
</recipe>'
```

## Библиотека `XML`

Для работы с xml понадобится установить одноименную библиотеку. Функция `xmlTreeParse()` создаст R-структуру, представляющую дерево XML.

```{r}
library(XML)
doc <- xmlTreeParse(string_xml)
class(doc)
```

Функция `xmlRoot()` позволяет извлечь корневой элемент вместе со всеми детьми. 

```{r}
rootnode <- xmlRoot(doc)
rootnode
```
 
Если документ большой, бывает удобнее не распечатывать все дерево, а вывести имена дочерних элементов.

```{r}
names(xmlChildren(rootnode))
```

Размер узла -- это число вложенных в него "детей". Его можно узнать, применив к узлу функцию `xmlSize()` -- или посчитав число "детей".

```{r}
xmlSize(rootnode) == length(xmlChildren(rootnode))
```

## Выбор элементов

Работать с xml можно как с обычным списком, то есть индексировать узлы по имени или по номеру элемента при помощи квадратных скобок. Так мы достаем узел по имени:

```{r}
rootnode[["composition"]]
```

А так -- по индексу:

```{r}
rootnode[[2]]
```

Как и с обычными списками, мы можем использовать последовательности квадратных скобок:

```{r}
ingr_node <- rootnode[[2]][["ingredient"]]
ingr_node
```

## Значения узлов и атрибутов

Но обычно нам нужен не элемент как таковой, а его содержание (значение). Чтобы добраться до него, используем функцию `xmlValue()`:

```{r}
xmlValue(ingr_node)
```

Можно уточнить атрибуты узла при помощи `xmlAttrs()`:

```{r}
xmlAttrs(ingr_node)
```

Чтобы извлечь значение атрибута, используем функцию `xmlGetAttr()`. Первым аргументом функции передаем xml-узел, вторым -- имя атрибута.

```{r}
xmlGetAttr(ingr_node, "unit")
```

## Обход дерева узлов

Как насчет того, чтобы применить функцию к набору узлов -- например, ко всем инредиентам? Вспоминаем функции для работы со списками -- `sapply()` из базового R или `map()` из пакета `purrr`: 

```{r}
ingr_nodes <- xmlChildren(rootnode[[2]])

sapply(ingr_nodes, xmlValue)
```


```{r}
sapply(ingr_nodes, xmlGetAttr, "unit")
```

## Синтаксис XPath

Добраться до узлов определенного уровня можно также при помощи синтаксиса [XPath](https://ru.wikipedia.org/wiki/XPath). XPath -- это язык запросов к элементам XML-документа. С его помощью можно описать "путь" до нужного узла: **абсолютный** (начиная с корневого элемента) или **относительный**. В пакете `XML` синтаксис XPath поддерживает функция `getNodeSet()`.

```{r}
# абсолютный путь
ingr_nodes <- getNodeSet(rootnode, "/recipe//composition//ingredient")

ingr_nodes
```

```{r}
# относительный путь
ingr_nodes <- getNodeSet(rootnode, "//composition//ingredient")

ingr_nodes
```

</br>

:::{.callout-note icon=false}
В большинстве случаев функция `getNodeSet()` требует задать **пространство имен** (namespace), но в нашем случае оно не определено, поэтому пока передаем только дерево и путь до узла. С пространством имен встретимся чуть позже!
:::

</br>

Синтаксис XPath позволяет отбирать узлы с определенными атрибутами. Допустим, нам нужны только те узлы, где значение атрибута unit = "стакан":

```{r}
getNodeSet(rootnode, "//composition//ingredient[@unit='стакан']")
```

## От дерева к таблице 

При работе с xml в большинстве случаев наша задача -- извлечь значения определеннных узлов или их атрибутов и сохранить их в прямоугольном формате.
Один из способов выглядит так.

```{r}
tibble(title = xmlValue(rootnode[["title"]]), 
       ingredients = map_chr(xmlChildren(rootnode[["composition"]]), xmlValue),
       unit = map_chr(xmlChildren(rootnode[["composition"]]), xmlGetAttr, "unit"),
       amount = map_chr(xmlChildren(rootnode[["composition"]]), xmlGetAttr, "amount")) |> 
  print()
       
```

