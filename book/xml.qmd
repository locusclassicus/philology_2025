# Разметка TEI XML

XML (от англ. eXtensible Markup Language) --- расширяемый язык разметки. Слово "расширяемый" означает, что список тегов не зафиксирован раз и навсегда: пользователи могут вводить свои собственные теги и создавать так называемые _настраиваемые языки разметки_ [@xml2004, 29]. Один из таких настраиваемых языков -- это TEI (Text Encoding Initiative), о котором будет сказано дальше. 

Для работы нам понадобятся следующие библиотеки:

```{r message=FALSE}
library(tidyverse)
library(xml2)
```


## Основы XML

Назначение языков разметки заключается в описании структурированных документов. Структура документа представляется в виде набора вложенных в друг друга элементов (дерева XML). У элементов есть открывающие и закрывающие теги. 
Все составляющие части документа обобщаются в пролог и корневой элемент. Корневой элемент — обязательная часть документа, в которую вложены все остальные элементы. Пролог может включать объявления, инструкции обработки, комментарии.

В правильно сформированном XML открывающий и закрывающий тег вложенного элемента всегда находятся внутри одного родительского элемента.

Создадим простой XML из строки. Сначала идет инструкция по обработке XML (со знаком вопроса), за ней следует объявление типа документа (с восклицательным знаком) и открывающий тег корневого элемента. В этот корневой элемент вложены все остальные элементы.

```{r}
string_xml <- '<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE recipe>
<recipe name="хлеб" preptime="5min" cooktime="180min">
   <title>
      Простой хлеб
   </title>
   <composition>
      <ingredient amount="3" unit="стакан">Мука</ingredient>
      <ingredient amount="0.25" unit="грамм">Дрожжи</ingredient>
      <ingredient amount="1.5" unit="стакан">Тёплая вода</ingredient>
   </composition>
   <instructions>
     <step>
        Смешать все ингредиенты и тщательно замесить. 
     </step>
     <step>
        Закрыть тканью и оставить на один час в тёплом помещении. 
     </step>
     <step>
        Замесить ещё раз, положить на противень и поставить в духовку.
     </step>
   </instructions>
</recipe>'
```

### Библиотека `xml2`

Для работы с xml понадобится установить библиотеку `xml2`. Функция `read_xml()` создаст объект, представляющий дерево XML.

```{r}
doc <- read_xml(string_xml)
class(doc)
```

Функция `xml_root()` позволяет извлечь корневой элемент вместе со всеми детьми. 

```{r}
rootnode <- xml_root(doc)
rootnode
```
 
У корневого элемента есть "дети". Это набор узлов.

```{r}
xml_children(rootnode)
```

У детей есть имена, которые можно извлечь специальной функцией. 

```{r}
xml_name(xml_children(rootnode))
```

### Выбор элементов

Обращаться к узлам можно по имени или по индексу. 

```{r}
# 1. Выбрать узел по имени:
composition_node <- xml_find_first(rootnode, "composition")
composition_node
```
```{r}
# 2. Выбрать узел по индексу (например, второй дочерний узел):
composition_node <- xml_children(rootnode)[[2]]
composition_node
```
```{r}
# 3. Комбинировать выбор: второй узел -> первый элемент:
ingr_node_1 <- xml_find_first(composition_node, "ingredient")
ingr_node_1
```

### Значения узлов и атрибутов

Но обычно нам нужен не элемент как таковой, а его содержание (значение). Чтобы добраться до него, используем функцию `xml_text()`:

```{r}
xml_children(composition_node) |> 
  xml_text()
```

Можно уточнить атрибуты узла при помощи `xml_attrs()`:

```{r}
xml_children(composition_node) |> 
  xml_attrs()
```

Чтобы извлечь значение атрибута, используем функцию `xml_attr()`. Первым аргументом функции передаем xml-узел, вторым -- имя атрибута.

```{r}
xml_attr(xml_children(composition_node), "unit")
```


### Синтаксис XPath

Добраться до узлов определенного уровня можно также при помощи синтаксиса [XPath](https://ru.wikipedia.org/wiki/XPath). XPath -- это язык запросов к элементам XML-документа. С его помощью можно описать "путь" до нужного узла: **абсолютный** (начиная с корневого элемента) или **относительный**. В пакете `xml` синтаксис XPath поддерживает функция `xml_find_all()`.

```{r}
# абсолютный путь
xml_find_all(rootnode, "/recipe//composition//ingredient")

# относительный путь
xml_find_all(rootnode, "//composition//ingredient")

# атрибут unit == "стакан"
xml_find_all(rootnode, "//composition//ingredient[@unit='стакан']")
```


:::{.callout-note icon=false}
В большинстве случаев функция требует задать **пространство имен** (namespace), но в нашем случае оно не определено, поэтому пока передаем только дерево и путь до узла. С пространством имен встретимся чуть позже!
:::

### От дерева к таблице

При работе с xml в большинстве случаев наша задача -- извлечь значения определеннных узлов или их атрибутов и сохранить их в прямоугольном формате. 

```{r}
# Получаем узлы:
title <- xml_find_all(rootnode, "title") |> 
  xml_text() |> 
  trimws()

ingredient_ns <- xml_find_all(rootnode, "//composition//ingredient")

tibble(
  title  = title,
  ingredients = xml_text(ingredient_ns),
  unit = xml_attr(ingredient_ns, "unit"),
  amount = xml_attr(ingredient_ns, "amount")
) |> 
  print()
```

Теперь рассмотрим более сложные примеры.

## Разметка TEI

TEI (Text Encoding Initiative) — специализированный язык разметки на основе XML, разработанный как средство формального кодирования наиболее значимых текстологических свойств документа: физических параметров рукописи, критического аппарата, лингвистической информации, выходных данных, сведений об авторе, обстоятельствах публикации и первоисточнике [@skorinkin2016]. TEI появился в 1987 г. и в наши дни стал де-факто стандартом для создания цифровых гуманитарных ресурсов.

Основная задача структурированной разметки — формальное эксплицитное представление некоторых свойств документа, заложенных в нем имплицитно. Например, для человека очевидно, где в тексте романа кончается одна часть и начинается другая, какие герои упоминаются в той или иной главе, какие реплики кем произнесены. Однако для машины ничего из этого не является «очевидным» — электронный текст без разметки остается не более чем цепочкой символов.

Большая часть размеченных литературных корпусов хранится именно в формате XML. Это очень удобно, и вот почему: с  помощью тегов XML мы можем достать из документа именно то, что нам интересно: определенную главу, речи конкретных персонажей, слова на иностранных языках и т.п. 

Использование TEI обеспечивает:

- Хранение богатой метаинформации о тексте и его носителях;
- Кодирование структуры текста и лингвистической разметки;
- Независимость от конкретного ПО;
- Открытость для доработки и расширения;
- Оптимизацию для автоматической обработки.

Добавлять и удалять разметку может любой пользователь в редакторе XML кода или даже в простом текстовом редакторе. Стандарт TEI предоставляет исследователям универсальный метаязык для обмена текстологической информацией и встраивает документы в мировую коллекцию машиночитаемых текстов.

### Структура документа TEI

Корневой элемент в документах TEI называется `TEI`, внутри него располагается элемент `teiHeader` с метаинформацией о документе и элемент `text`. Последний содержит текст документа с элементами, определяющими его структурное членение. 

```
<TEI>
  <teiHeader></teiHeader>
  <text></text>
</TEI>
```

Пример оформления документа можно посмотреть [по ссылке](https://github.com/dracor-org/rusdracor/blob/main/tei/fonvizin-nedorosl.xml).

### teiHeader

У `teiHeader` есть четыре главных дочерних элемента:

- `fileDesc` (описание документа c библиографической информацией)
- `encodingDesc` (описание способа кодирование первоисточника)
- `profileDesc` ("досье" на текст, например отправитель и получатель для писем, жанр, используемые языки, обстоятельства создания, место написания и т.п.)
- `revisionDesc` (история изменений документа).


Элемент `fileDesc` должен содержать полную библиографическую информацию о первоисточнике. Пример для повести Л.Н. Толстого «Детство»:

```
<fileDesc>
  <titleStmt>
    <title>Повесть «Детство». Электронное издание.</title>
    <author>Толстой Л.Н.</author>
    <editor>Иванов И.И.</editor>
    <respStmt>
      <resp>Подготовка и разметка метаинформации для электронного издания</resp>
      <name>Иванов И.И.</name>
    </respStmt>
  </titleStmt>
  <publicationStmt>
    <publisher>Школа лингвистики <orgName>НИУ ВШЭ</orgName></publisher>
    <availability>
      <p>Распространяется свободно</p>
    </availability>
  </publicationStmt>
  <sourceDesc>
    <biblStruct>
      <author>Толстой Л.Н.</author>
      <title level="a">Детство</title>
      <monogr>
        <title level="m">Полное собрание сочинений. Том 1</title>
        <imprint>
          <pubPlace>Москва</pubPlace>
          <publisher>Государственное издательство "Художественная литература"</publisher>
          <date when="1935"/>
        </imprint>
      </monogr>
    </biblStruct>
  </sourceDesc>
</fileDesc>
```


Элемент `<profileDesc>` содержит метаданные, относящиеся непосредственно к тексту:

```
<profileDesc>
  <creation>
    <date when="1852">1852</date>
    <placeName>Москва</placeName>
    <placeName>станица Старогладковская</placeName>
    <placeName>Тифлис</placeName>
  </creation>
  <langUsage>
    <language ident="rus" usage="99">Русский</language>
    <language ident="fra" usage="0,5">Французский</language>
    <language ident="deu" usage="0,5">Немецкий</language>
  </langUsage>
  <textClass>
    <catRef type="type" target="#short_novel"/>
  </textClass>
</profileDesc>
```

### Варианты и исправления

В самом тексте язык TEI дает возможность представлять разные варианты (авторские, редакторские, корректорские и др.) Основным средством параллельного представления является элемент `choice`. Например, в [тексте Лукреция](https://github.com/PerseusDL/canonical-latinLit/blob/master/data/phi0550/phi001/phi0550.phi001.perseus-lat1.xml) вы можете увидеть такое:

```
sic calor atque <choice><reg>aer</reg><orig>aër</orig></choice> et venti caeca potestas
```

Здесь `reg` указывает на нормализованное написание, а `orig` -- на оригинальное.

Для исправления ошибок используются элементы `<sic>` («так у автора») и `<corr>` («исправленное написание»):

```
<choice>
  <sic>вихремъ</sic>
  <corr resp="#editor1">верхомъ</corr>
</choice>
```

Атрибут `resp` содержит ссылку на идентификатор редактора.

### Структурная разметка

TEI предоставляет богатый набор элементов для разметки структуры текста:

- `<text>` — текст целиком
- `<body>` — основное содержание текста
- `<div>` — структурное деление (глава, часть, раздел)
- `<p>` — параграф
- `<l>` — стихотворная строка
- `<lg>` — группа стихотворных строк (строфа)
- `<sp>` — речь персонажа в драме
- `<stage>` — ремарка

Пример разметки поэзии:

```
<lg type="quatrain">
  <l met="+-|+-|+-|+-">Дар напрасный, дар случайный,</l>
  <l met="+-|+-|+-|+">Жизнь, зачем ты мне дана?</l>
  <l met="+-|+-|+-|+-">Иль зачем судьбою тайной</l>
  <l met="+-|+-|--|+">Ты на казнь осуждена?</l>
</lg>
```


## Кейс: "Горе от ума"

Скачаем по из репозитория проекта [Dracor](https://github.com/dracor-org) "Горе от ума" Грибоедова и преобразуем xml в прямоугольный формат таким образом, чтобы для каждой реплики был указан акт, сцена и действующее лицо.

:::{.callout-note icon=false}
Для работы с корпусом Dracor в среде R существует пакет `rdracor`. Он позволяет доставать тексты пьес сразу в виде таблицы. 
:::

```{r eval=FALSE}
url <- "https://raw.githubusercontent.com/dracor-org/rusdracor/main/tei/griboyedov-gore-ot-uma.xml"
download_xml(url, file = "griboedov.xml")
```

```{r}
doc <- read_xml("griboedov.xml")

# определить пространство имён
ns <- xml_ns(doc)
ns
```

Пространство имён (namespace) в XML — это механизм, который позволяет однозначно различать элементы и атрибуты с одинаковыми именами, но из разных словарей или стандартов. Оно действует как "фамилия" для элемента. Чтобы задать "фамилию", её связывают с уникальным идентификатором (обычно это URI, в нашем случае <http://www.tei-c.org/ns/1.0>). Для удобства этому идентификатору присваивают короткий префикс.


```{r}
# Найти все строки (tei:l)
line_nodes <- xml_find_all(doc, "//d1:l", ns)

# Извлечь текст каждой строки
line_text <- xml_text(line_nodes)

line_text |> 
  head()
```
Теперь нам надо для каждой реплики найти информацию о том, кто говорит: она хранится в  теге `<speaker>`. То есть нам надо подняться на два этажа вверх (на уровень `<sp>`), а потом спуститься к его другому "ребенку", `<speaker>`.
Для этого используем синтаксис XPath: сначала при помощи `ancestor::d1:sp` поднимаемся вверх по дереву и выбираем всех предков узла, которые являются элементами `sp`, а затем спускаемся к ребенку `speaker` этого найденного `sp`. Так список спикеров будет равно числу стихов. 

```{r}
# line_nodes — вектор узлов <l>
speakers <- xml_find_first(line_nodes, "ancestor::d1:sp/d1:speaker", ns = ns) |> 
  xml_text()

speakers |> 
  head()
```

Аналогичным образом находим явление и акт.

```{r}
scenes <- xml_find_first(line_nodes, "ancestor::d1:div[@type='scene']/d1:head", ns = ns) |> 
  xml_text()

scenes |> 
  tail()
```

```{r}
acts <- xml_text(
  xml_find_first(line_nodes, "ancestor::d1:div[@type='act']/d1:head", ns = ns)
)

acts |> 
  sample(6)
```

Нам осталось объединить все векторы в одну таблицу. 

```{r}
woe_from_wit <- tibble(
  act = acts,
  scene = scenes,
  speaker = speakers,
  text = line_text
)
```

```{r echo=FALSE}
woe_from_wit |> 
  head(6) |> 
  gt::gt()
```

## Видео к уроку

- [Видео](https://vk.com/video91786643_456239082) 2025 г.

## Домашнее задание

- **Дедлайн**: 14 ноября 21-00.

- **Ссылка**: <https://classroom.github.com/a/l-jxHG39> 

- **Оценивание**: 0/1

- Данные, подробные инструкции и заготовку для скрипта вы найдете в репозитории. Репозиторий надо клонировать (создать новый локальный проект под контролем версий), отредактировать скрипт согласно инструкции (не переименовывайте файл!), запушить изменения. 

- Проверка автоматическая, обычно занимает до 20 минут, выполняется после каждого коммита / пуша. Можно пушить сколько угодно раз до дедлайна. В случае прохождения всех тестов (после обновления страницы) вы увидите зеленую галочку. 

![](images/success.png)

- Почему это не быстро? Потому что GitHub Actions при каждой проверке запускает "чистую" виртуальную машину (как правило, Ubuntu), где установлены только базовые вещи типа R, Python и т.д. 

- Если тесты не пройдены, напротив коммита будет красный крест. 

![](images/fail.png)

- Вы можете пройти на вкладку Actions (см. фото выше), найти там свой коммит (вы же его как-то назвали, помните?) и _посмотреть ошибку_. После исправления ошибки сделайте новый коммит. 

Вот так выглядит вкладка Actions. Желтый цвет означает, что workflow в работе.

![](images/actions.png)
Если нажать на коммит (здесь: `sumbit hw xml`) -> `test` -> `Run tests`, можно увидеть детали проверки. 

![](images/run_tests.png)

- Внимательно читайте сообщения об ошибках! Их можно и нужно показывать LLM (например, DeepSeek), которые помогут доработать код.  

- Ваша задача: добиться прохождения всех тестов! В противном случае задание не засчитывается. 

___

Подбробнее о структуре XML документов и способах работы с ними вы можете прочитать в книгах: [@nolan2014] и [@xml2004]. 